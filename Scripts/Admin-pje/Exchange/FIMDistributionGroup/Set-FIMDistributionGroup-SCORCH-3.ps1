## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
$ResultStatus = ""
$ErrorMessage = ""
$Trace = (Get-Date).ToString() + "`t" + "Runbook activity script started" + " `r`n"

# Cred
$password = "76492d1116743f0423413b16050a5345MgB8AHoAdgBkAGwAeABrAFoAYQBVAEsAbgBoAHAAbABaAHUAYwBCAFcAQgBlAGcAPQA9AHwAYQA5AGIAYQAzADcANgAzADcAMQA5ADIAOQBjADkAZQBiADUAZgA2ADkAZABjADkAZgA0ADYAZgBmADQAZgA0AGEAYwBjAGUAYgBiADcAMAAxAGQAMQAxADUAYQA5ADEAMgBhAGUAOQBjAGIAOAAxADEAYQAyAGUANgA1ADUAOAA="
$key = "25 87 22 128 58 55 6 185 163 103 128 234 246 56 146 167 35 19 193 164 124 125 54 132 216 127 241 172 102 18 163 207"
$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(" "))
$cred =  New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "prd\admin-pje",$passwordSecure

# Establish an external session (to DC) to ensure 64bit PowerShell runtime using the latest version of PowerShell installed on the DC
$Session = New-PSSession -ComputerName DKHQEXCMAN02.prd.eccocorp.net -Cred $cred -Authentication Credssp

# Invoke-Command used to start the script in the external session. Variables returned by script are then stored in the $ReturnArray variable
$ReturnArray = Invoke-Command -Session $Session -ScriptBlock {
    
    # Function to add entry to trace log variable
    function AppendLog ([string]$Message){
        $script:CurrentAction = $Message
        $script:TraceLog += ((Get-Date).ToString() + "`t" + $Message + " `r`n")
    }

    # Set external session trace and status variables to defaults
    $ResultStatus = ""
    $ErrorMessage = ""
    $script:CurrentAction = ""
    $script:TraceLog = ""

    try {
        # Add startup details to trace log
        AppendLog "Script now executing in external PowerShell version [$($PSVersionTable.PSVersion.ToString())] session in a [$([IntPtr]::Size * 8)] bit process"
        AppendLog "Running as user [$([Environment]::UserDomainName)\$([Environment]::UserName)] on host [$($env:COMPUTERNAME)]"

        # The actual logic
        AppendLog "Importing ActiveDirectory Module"
		Import-Module ActiveDirectory
        Add-PSSnapin Quest.ActiveRoles.ADManagement
		
		AppendLog "Getting filtered DistributionsGroups from SearchBase 'OU=Distribution Lists,OU=EXCHANGE,DC=prd,DC=eccocorp,DC=net'"
		$allDL = ((Get-ADGroup -SearchBase "OU=Distribution Lists,OU=EXCHANGE,DC=prd,DC=eccocorp,DC=net" -Filter `
		 {((GroupCategory -eq "Distribution") -and (Name -notlike "*O_*") -and (Name -notlike "*N_*"))} -ErrorAction Stop).SamAccountName)

        AppendLog "Enumerating returned DistributionsGroups"
		
		try
		{
			foreach ($dl in $allDL) {
				AppendLog "Processing DistributionGroup $dl"
				(Get-ADGroupMember -Identity $dl -ErrorAction Stop | Where {($_.objectClass -match 'User')}) | ForEach-Object {AppendLog "Removing $_.SamAccountName From $dl";Remove-ADGroupMember -Identity $dl -Member $_.SamAccountName -Confirm:$false -ErrorAction Stop}
			
				AppendLog "Get InnerGroups"
				$iGroups = ((Get-ADGroupMember -Identity $dl -ErrorAction Stop | where {($_.name -like 'O_*' -or $_.name -like 'N_*') -and ($_.objectClass -match 'Group')}).SamAccountName)
							
				foreach ($grp in $iGroups) {
					AppendLog "Enumerate InnerGroups [$grp]"
					Get-ADGroupMember $grp -ErrorAction Stop | ForEach-Object {AppendLog "Adding $_.SamAccountName to $dl";Add-ADGroupMember -Identity $dl -Members $_.SamAccountName -ErrorAction Stop}
				}
			}
		}
		
		catch
		{
			$ErrorMessage = $error[0].Exception.Message
        	AppendLog "Exception caught during action [$script:CurrentAction]: $ErrorMessage"
		}

        # Validate results and set return status
        AppendLog "Finished work, determining result"
        $EverythingWorked = $true
        if($EverythingWorked -eq $true){
           $ResultStatus = "Success"
        }
        else{
            $ResultStatus = "Failed"
        }
    }
    catch{
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        AppendLog "Exception caught during action [$script:CurrentAction]: $ErrorMessage"
    }
    finally{
        # Adding some additional detail about the outcome to the trace log for return
        if($ErrorMessage.Length -gt 0){
            AppendLog "Exiting external session with result [$ResultStatus] and error message [$ErrorMessage]"
        }
        else{
            AppendLog "Exiting external session with result [$ResultStatus]"
        }
    }

    # Return an array of the results.
    $resultArray = @()
    $resultArray += $ResultStatus
    $resultArray += $ErrorMessage
    $resultArray += $script:TraceLog
    return  $resultArray  
     
}#End Invoke-Command

# Get the values returned from script session for publishing to data bus
$ResultStatus = $ReturnArray[0]
$ErrorMessage = $ReturnArray[1]
$Trace += $ReturnArray[2]

# Record end of activity script process
$Trace += (Get-Date).ToString() + "`t" + "Script finished" + " `r`n"

Out-File "C:\logs\Orchestrator\2.2.1.2 - FIM DistributionGroup Sync\TraceLog.txt" -InputObject $Trace

# Close the external session
Remove-PSSession $Session